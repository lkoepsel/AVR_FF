Dictionary of FlashForth 5 15.04.2022

!          ( x addr -- )
           Store x to addr

!p         ( addr -- )
           Store addr to p(ointer) register

!p>r       ( addr -- )   COMPILE_ONLY
           Push contents of p to return stack and stor addr to p

#          ( ud1 -- ud2 )  COMPILE_ONLY
           Convert 1 digit to formatted numeric string

#>         ( ud1 -- c-addr u )  COMPILE_ONLY
           Leave address and count of formatted numeric string

#s         ( ud1 -- ud2 )  COMPILE_ONLY
           Convert remaining digits to formatted numeric output

'          ( -- xt )
           Parse word and find it in dictionary

'emit      ( -- addr )  User Variable
           EMIT vector. TX0, TX1, TX2, TX3 or TXU

'key       ( -- addr )  User Variable
           KEY vector.  RX0, RX1, RX2, RX3 or RXU

'key?      ( -- addr )  User Variable
           KEY? vector. RX0?, RX1?, RX2?, RX3? or RXU?

'source    ( -- a-addr )     User Variable 
           Current input source

(          ( -- )
           Skip input on the same line until ) is encountered

*          (u1/n1 u2/n2 -- u3/n3
           Signed and unsigned 16*16->16 bit multiplikation

*/         ( n1 n2 n3 -- quotient )
           Multiply n1 and n2 and divide with n3. 32 bit intermediate result.

*/mod      ( n1 n2 n3 -- rem quot )
           Multiply n1 with n2 and divide with n3 via 32-bit 
           intermediate result

+          ( n1 n2 -- n3 )
           Add n1 to n2

+!         ( n addr -- )
           Add n to cell at addr.

+loop      ( n -- )  COMPILE_ONLY
           Add n to the loop index and terminate the loop if the limit has been reached.

,          ( x -- )
           Append x to the current data section

,"         ( "string" -- )
           Append a string at HERE.

-          ( n1 n2 -- n3 )
           Subtract n2 from n1

-@         ( a-addr -- a-addr-2 n )
           Fetch from a-addr and decrement a-addr by 2

.          ( n -- )
           Display n signed according to base

.s         ( -- )
           Display the stack contents

.st        ( -- )
           Emit status string for base, current data section,
           and display the stack contents.

/          ( n1 n2 -- n3 )
           16/16->16 bit signed division
           
/mod       ( n n  -- rem quot )
           16/16 -> 16-bit signed division.

/string    ( addr u n -- addr+n u-n )
           Trim string

0<         ( n -- flag )
           Leave true flag if n is less than zero

0=         ( x -- flag )
           Leave true flag if x is zero

1          ( -- 1 ) 
           Leave one

1+         ( n -- n1 )
           Add one to n

1-         ( n -- n1 )
           Subtract 1 from n

2*         ( u1 -- u2 )
           Shift u1 left one bit

2+         ( n -- n1 )
           Add two to n

2-         ( n -- n1 )
           Subtract 2 from n

2/         (n1 -- n2 )
           Shift n1 right one bit.

2@         ( a-addr -- x1 x2 )
           Fetch two cells

2!         ( x1 x2 a-addr -- )
           Store two cells. x1 to lower address. x2 to higher address

2constant  ( x x "name" -- )
           Define a double constant

2drop      ( x1 x2 -- )
           Drop two cells

2dup       ( x1 x2  -- x1 x2 x1 x2 )
           Duplicate two top cells

2over      ( x1 x2 x3 x4 --  x1 x2 x3 x4 x1 x2 )
           PIC18

2literal   ( x x -- )
           Compile a double literal 

2variable  ( "name" -- )
           Define a double variable

:          ( "name" -- )
           Begin a colon definition

:noname    ( -- addr )
           Define headerless forth code

;          ( -- )    COMPILE_ONLY
           End a colon definition

;i         ( -- )    COMPILE_ONLY
           End a interrupt word

<          ( n1 n2 -- flag )
           Leave true flag if n1 is less than n2

<#         ( -- )        Compile Only
           Begin numeric conversion

<>         ( x1 x2 -- flag )
           Leave true flag if x1 and x2 are not equal

=          ( x1 x2 -- flag )
           Leave true flag if x1 and x2 are equal

>          ( n1 n2 -- flag )
           Leave trye flag if n1 is grater than n2

>a         ( x -- )
           Write to the A register

>body      ( xt -- a-addr )
           Leave the data field address of 
           a created word

>in        ( -- a-addr )      User Variable
           Holds offset into tib

>number    ( ud  c-addr1 u1 -- ud c-addr2 u2 )
           Convert string to number

>pr        ( c -- c )
           Convert a character to a graphic ASCII value.
           Non-graphic characters are converted to a dot.

>r         ( x -- ) ( R: -- x )  COMPILE_ONLY
           Push x from the parameter stack to the return stack

>xa        ( a-addr1 -- a-addr2 )
           Convert a flash virtual address to real executable address.
           PIC24-30-33 ATMEGA

?abort     ( flag c-addr u -- )
           Print message and abort if flag is false

?abort?    ( flag -- )
           If flag is false output ? and abort

?do        ( limit index -- )  COMPILE_ONLY
           Start a do loop which is not run if the arguemnts are equal

?dnegate   ( d n -- d )
           Negate d if n is negative
           
?negate    ( n1 n2 -- n3 )
           Negate n1 if n2 is negative

@          ( a-addr -- x )
           Fetch x from a-addr

@+         ( a-addr1 -- a-addr2 x )
           Fetch cell from a-addr1 and increment a-addr1 by cellsize
           
@p         ( -- addr )
           Fetch the p register to the stack

@ex        ( addr -- )
           Fetch vector from addr and execute.

[          ( -- )
           Enter interpreter state

[']        ( "name" -- )   COMPILE_ONLY
           Compile xt of name as a literal

[char]     ( "char" -- )   COMPILE_ONLY
           Compile inline ascii character

[i         ( -- )   COMPILE_ONLY
           Enter Forth interrupt context
           PIC18 PIC24-30-33

\          ( -- )
           Skip rest of line

]          ( -- )
           Enter compilation state

a>         ( -- x )
           Read from the A register

abort      ( -- )
           Reset stack pointer and execute quit

abort"     ( "string" -- )  COMPILE_ONLY
           Compile inline string and postpone ?abort

abs        ( n -- n1 )
           Leave absolute value of n

accept     ( c-addr +n -- +n' )
           Get line from terminal

again      ( a-addr -- )  COMPILE_ONLY
           begin ... again

aivt       ( -- )
           Activate the alternate interrupt vector table
           Not PIC24E PIC33E

align      ( -- )
           Align the current data section dictionary pointer
           to cell boundary

aligned    ( addr -- a-addr )
           Align addr to a cell boundary.

allot      ( n -- )
           Adjust the current data section dictionary pointer

and        ( x1 x2 -- x3 )
           Bitwise and of x1 and x2

base       ( -- a-addr )     User Variable
           Numeric conversion base

begin      ( -- a-addr )  COMPILE_ONLY
           begin ... again
           begin ... until
           begin ... while ... repeat

bin        ( -- )
           Set base to binary

bl         ( -- c )
           Ascii space

busy       ( -- )
           Cpu idle mode not allowed
           
c!         ( c c-addr -- )
           Store c to c-addr

c@         ( c-addr -- c )
           Fetch c from addr

c@+        ( c-addr1 -- c-addr2 c )
           Fetch char from addr1 and increment addr1

c,         ( c -- )
           Append c to the current data section

case       ( n -- n ) COMPILE_ONLY
	   Start a case construct

cell       ( -- n )
           Leave the size of one cell in characters.

cell+      ( a-addr1 -- a-addr2 )
           Add cell size to addr1

cells      ( n1 -- n2 )
           Convert cells to address units.

char       ( "char" -- n )
           Parse a char and leave ascii value on stack

char+      ( c-addr1 -- c-addr2 )
           Add one to c.addr1

chars      ( n1 -- n2 )
           Convert characters to address units

cf,        ( xt -- )
           Compile xt into the flash dictionary.

c>n        ( addr1 -- addr2 )
           Convert cfa to nfa

cmove      ( addr1 addr2 u -- )
           Move u chars from addr1 to addr2

constant   ( x "name" -- )
           Create a constant in flash as inline literal code

cq>        ( queue-addr -- c )
           Get a character from queue.
           PIC24

cq>?       ( queue-addr -- n )
           Get the amount of characters in the queue.
           PIC24

cq:        ( size "name" -- )
           Create a character queue
           PIC24

cq0        ( queue-addr -- )
           Initalise the queue.
           PIC24

cr         ( -- )
           Emit CR LF

create     ( "name" -- )
           Create a word definition and store the current
           data section pointer.

cwd        ( -- )
           Clear the WatchDog counter.
           
d+         ( d d -- d )
           Add double numbers
           
d-         ( d d -- d )
           Subtract double numbers
           
d.         ( d -- )
           Display signed double number.
           
d0=        ( d -- f )
           True if d equals zero
           
d0<        ( d -- f )
           True if d is negative
           
d<         ( d d -- f )
           True if less than
           
d=         ( d d -- f )
           True if equal

d>         ( d d -- f )
           True if greater than
           
d2*        ( d -- d )
           Multiply by 2

d2/        ( d -- d )
           Divide by 2

dabs       ( d - +d )
           Absolute value

decimal    ( -- )
           Set numeric base to decimal 10.

default    ( n --  )
           Default branch in case statement

defer      ( "name -- )
           Define a deferred execution vector

di         ( -- )
           Disable interrupts

digit      ( n -- c )
           Convert n to ascii character value

digit?     ( c -- n flag )
           Convert char to a digit according to base
           
dinvert    ( ud -- ud )
           Invert double number

dnegate    ( d -- -d )
           Negate double number

do         ( limit index --) COMPILE_ONLY
           Start a do loop
           
does>      ( -- )  COMPILE_ONLY
           Define the runtime action of a created word.

dp         ( -- addr )       Eeprom variable mirrored in ram
           Leave the address of the current data section
           dictionary pointer

dps        ( -- d )
           End address of Dictionary Pointers. 
           Absolute address of start of free flash.
           Library and C code can be linked starting at this address.
           PIC24 and dsPIC33

drop       ( x1 -- )
           Drop top of stack

dump       ( addr u -- )
           Display a memory dump 

dup        ( x -- x x )
           Duplicate top of stack

ei         ( -- )
           Enable interrupts

end        ( task-addr -- )
           Remove a task from the task list.

eeprom     ( -- )
           Set data section context to eeprom

else       ( addr1 -- addr2 ) COMPILE_ONLY
           if ... else ... then

emit       ( c -- )
           Emit c to the serial port FIFO. FIFO is 46 chars.
           Executes pause.

empty       ( -- )
           Reset all dictionary pointers.

endcase    ( n -- ) COMPILE_ONLY
           End of case construct

endit      ( -- ) COMPILE_ONLY
           Leave a for/next loop when next is encountered.
           Sets top of return stack to zero

endof      ( -- ) COMPILE_ONLY
           of .. endof in case statement
         
evaluate   ( c-addr n -- )
           Evaluate buffer

execute    ( addr -- )
           Execute word at addr

exit       ( -- )
           Exit from a word.

false      ( -- 0 )

Fcy        ( -- u )
           The internal cpu & peripheral clock cycle in KHz.

fl-        ( -- )
           Disable writes to flash and eeprom.

fl+        ( -- )
           Allow writes to flash and eeprom.

flash      ( -- )
           Set data section context to flash

fill       ( c-addr u c -- )
           Fill u bytes with c staring at c-addr

find       ( c-addr -- c-addr 0/1/-1 )
           Find a word in dictionary
           Leave 1 if immediate, -1 if normal, 0 if not found

fm/mod     (d n -- rem quot )
           Floored 32/16 -> 16-bit division
           
for        ( u -- )   COMPILE_ONLY
           Loop u times. for ... next
           R@ gets the loop counter  u-1 ... 0

forget     ( "name -- )
           Forget name

here       ( -- addr )
           Leave the current data section dictionary pointer

hex        ( -- )
           Set numeric base to hexadecimal

hi         ( -- u )
           High limit of the current data space memory.

hold       ( c -- )  COMPILE_ONLY
           Append char to formatted numeric string

hp         ( -- a-addr )  USER
           Hold pointer for formatted numeric output

i          ( -- n ) COMPILE_ONLY
           The loop index

i]         ( -- )   COMPILE_ONLY
           Exit Forth interrupt context
           PIC18 PIC24-30-33

i,         ( x -- )
           Append x to the flash data section.

ic,        ( c -- )
           Append c to the flash data section.

idle       ( -- )
           Cpu idle mode is allowed
           
if         ( -- a-addr )  COMPILE_ONLY 
           if ... else ... then

iflush     ( -- )
           Flush the flash write buffer

immed?     ( addr -- n )
           Leave a nonzero value if addr contains a immediate flag

immediate  ( -- )
           Mark latest definition as immediate

in?        ( nfa -- flag )
           Leave a nonzero value if nfa has inline bit set

inline     ( "name" -- )
           Inline the following word.

inlined    ( -- )
           Mark the latest compiled word as for automatic inlining.

int/       ( vector-no -- )
           Restore the original vector to the alternate table in flash
           PIC30 PIC24FK

int!       ( xt vector-no -- )
           Store an interrupt vector to the interrupt vector table.
           PIC18: Dummy vector number (0) for high prority interrupts.
           PIC30: Alternate interrupt vector table in flash.
           PIC33: Alternate interrupt vector table in ram.
           PIC24H: Alternate interrupt vector table in ram.
           PIC24F: Alternate interrupt vector table in ram.
           PIC24FK: Alternate interrupt vector table in flash.
           PIC24E: Main table in ram
           ATMEGA: Interrupt vector table in ram.

interpret  ( c-addr u - )
           Interpret the buffer

invert     ( x1 -- x2 )
           Ones complement of x1

is         ( x "name" -- )
           Set the value a deferred word

ivt        ( -- )
           Activate the normal interrupt vector table
           Not PIC24E PIC33E

j          ( -- n )  COMPILE ONLY
           The outer loop index

key        ( -- c )
           Get a character from the serial port FIFO.
           Execute pause until a character is available

key?       ( -- flag )
           Leave true if character is waiting in the serial port FIFO

latest       ( -- a-addr )
           Variable holding the address of the latest defined word

leave      ( -- )  COMPILE_ONLY
           Leave a DO LOOP immediately

literal    ( x -- )
           Compile a literal into the dictionary

load       ( -- n )
           Get the CPU load in percent.
           The integration interval is 256 milliseconds.

load+      ( -- )
           Enable on the load led.
           ATMEGA

load-      ( -- )
           Disable on the load led.
           ATMEGA

loop       ( -- )
           Increment the loop index and terminate the loop if the limit has been reached.
           
lshift     ( x1 u -- x2
           Shift x1 u bits to the left

m+         ( d1 n -- d2 )
           Add double number d1 to n

m*         ( n n -- d )
           Signed 16*16->32 multiply
           
m*/        ( d1 n1 n2 - d2 )
           Scale d2 = d1*n1/n2 with triple intermediate result

marker     ( "name" -- )
           Mark a dictionary state

max        ( n1 n2 -- n3 )
           Leave max of n1 and n2

mclr       ( mask addr -- )
           AND the contents of addr with the complement of mask
           PIC24-30-33: 16-bit operation
           ATMEGA and PIC18: 8-bit operation

min        ( n1 n2 -- n3 )
           Leave min of n1 and n2

mod        ( n1 n2 -- remainder )
           Remainder of n1 divided by n2
           
ms         ( +n -- )
           Pause for +n milliseconds

mset       ( mask addr -- )
           OR the contents of addr with mask.
           PIC24-30-33: 16-bit operation
           ATMEGA and PIC18: 8-bit operation

mtst       ( mask addr -- x )
           AND the contents of addr with mask
           PIC24-30-33: 16-bit operation
           ATMEGA and PIC18: 8-bit operation

n=         ( c-addr c-addr(nfa) -- flag )
           Compare strings in ram(c-addr) and flash(nfa)
           flag is zero if strings match. Length<16.

negate     ( n -- -n )
           negate n

next       ( bra-addr bc-addr -- )   COMPILE_ONLY
           for ... next

n>c        ( nfa -- cfa )

n>l        ( nfa -- lfa )
           Not implemented.
           Convert nfa to lfa. Use 2- instead

nip        ( x1 x2 -- x2 )
           Remove x1 from the stack

number?    ( c-addr -- n/d/c-addr flag )
           Convert string to number
           # is decimal prefix
           $ is hexadecimal prefix
           % is binary prefix
           Flag: 0=error, 1=single, 2=double

of         ( n -- )   COMPILE_ONLY
           Branch for value n in case statement

operator   ( -- addr )
           Leave the address of the operator task

or         ( x1 x2 -- x3 )
           Or bitwise x1 with x2

over       ( x1 x2 -- x1 x2 x1 )
           Copy x1 to top of stack

p+         ( -- )
           Increment P register by one

p2+        ( -- )
           Add 2 to P register

p++        ( n -- )
           Add n to the p register

p!         ( x -- )
           Store x to the location pointed by the p register

pc!        ( c -- )
           Store c to the location pointed by the p register

p@         ( -- x )
           Fetch the cell pointed by the p register

pc@        ( -- c )
           Fetch the char pointed by the p register

pad        ( -- a-addr )
           : pad tib ti# + ;
           Each task has its own pad with initial size of 0.
           If needed the user must allocate space with allot.
           FF core does not use the pad.

parse	   ( c -- addr length )
           Parse a word in TIB

pause      ( -- )
           Switch to the next task in the round robin task list.
	       Idle in the operator task if allowed by all tasks.

place      ( addr1 u addr2 -- )
           Place string from addr1 to addr2 as a counted string

postpone   ( "name" -- )          COMPILE_ONLY
           Postpone action of immediate word

prompt     ( -- a-addr )           Eeprom defer
           Deferred execution vector for the info displayed by quit.
           Default is .ST

quit       ( -- )
           Interpret from current input.

r>         ( -- x ) ( R: x -- )   COMPILE_ONLY
           Pop x from the return stack to the parameter stack

r>p        ( -- )                 COMPILE_ONLY
           Pop from return stack to p register

r@         ( -- x ) ( R: x -- x ) COMPILE_ONLY
           Copy x from the return stack to the parameter stack

r0         ( -- a-addr )          USER
           Bottom of return stack

ram        ( -- )
           Set data section context to ram

rdrop      ( -- )              COMPILE_ONLY
           Remove top elemnt from return stack

repeat     ( addr2 addr1 -- )  COMPILE_ONLY
           begin ... while ... repeat

rot        ( x1 x2 x3 -- x2 x3 x1 )
           Rotate three top stack items

rshift     ( x1 u -- x2 )
           Shift x1 u bits to the right

run        ( task-addr -- )
           Link the task to the task list. The task
           starts running immediately.

rx0        ( -- c )
           Receive a character from UART0.
           ATMEGA

rx0?       ( -- f )
           Leave TRUE if the UART0 receive buffer is not empty.
           ATMEGA

rx1        ( -- c )
           Receive a character from UART1.

rx1?       ( -- f )
           Leave TRUE if UART1 receive buffer is not empty.

rx1q       ( -- queue-addr )
           Leave the address of the queue for UART1. 
           PIC24-30-33

rx2        ( -- c )
           Receive a character from UART2.
           PIC18-24-30-33

rx2?       ( -- f )
           Leave TRUE if UART2 receive buffer is not empty.
           PIC18-24-30-33

rx2q       ( -- queue-addr )
           Leave the address of the queue for UART2.
           PIC24-30-33

rx3        ( -- c )
           Receive a character from UART3.
           PIC18

rx3?       ( -- f )
           Leave TRUE if UART3 receive buffer is not empty.
           PIC18

rxu        ( -- c )
           Receive a character from USB UART.
           PIC18-24 USB

rxu?       ( -- f )
           Leave TRUE if USB UART receive buffer is not empty. 
           PIC18-24 USB

s>d        ( n -- d )
           Sign extend single to double precision number
           
s0         ( -- a-addr )
           Bottom of parameter stack


scan       ( c-addr u c -- c-addr' u'
           Scan string until c is found.
           c-addr must point to ram. u<255

sign       ( n -- )
           Append minus sign to formatted numeric output

sign?      ( addr1 n1 -- addr2 n2 flag )
           Get optional minus sign

single     ( -- )
           End all tasks except the operator task.
           Removes all tasks from the task list
           except the operator task.

skip       ( c-addr u c -- c-addr' u' )
           Skip string until c not encountered.
           c-addr must point to ram. u<255

sm/rem     ( d n -- rem quot )
           Symmetric 32/16 -> 16 bit division
           
sp@        ( -- addr )
           Leave parameter stack pointer

sp!        ( addr -- )
           Set the parameter stack pointer to addr

s"         ( "text" -- )   COMPILE_ONLY
           Compile string into flash

."         ( "text" -- )   COMPILE_ONLY
           Compile string to print into flash

source     ( -- c-addr u )
           Current input buffer address and numbers of chracters

space      ( -- )
           Emit one space character

spaces     ( n -- )
           Emit n space characters

state      ( -- flag )         
           Compilation state. State can only be changed by [ and ] 

swap       ( x1 x2 -- x2 x1 )
           Swap two top stack items

task	   ( -- addr )
           Address of the task definition table

task:      ( tibsize stacksize rstacksize addsize -- )
           Define a task
           HINT:
           Use RAM xxx ALLOT to leave space for PAD if it is needed. 
           The OPERATOR task does not use PAD.  

tinit      ( taskloop-addr task-addr -- )
           Initialise the user area and link it to a task loop

then       ( addr -- )   COMPILE_ONLY
           if ... else ... then

tib        ( -- addr )     USER
           Address of the terminal input buffer

tiu        ( -- addr )     USER
           Terminal input buffer pointer

ti#        ( -- n )        Task constant
           Size of terminal input buffer

ticks      ( -- u )
           System ticks. One tick per millisecond.

to         ( x "name" -- )
           Store x into value "name".

true       ( -- -1 )

tuck       ( x1 x2 -- x2 x1 x2 )
           Insert x2 below x1 in the stack

turnkey    ( -- addr )
           Vector for user startup word
           Eeprom value cached in ram

type       ( c-addr u -- )
           Type line to terminal. u < 256

tx0        ( c -- )
           Send a character to UART 0.
           ATMEGA

tx1        ( c -- )
           Send a character to UART 1.

tx1q       ( -- queue-addr )
           Leave the address of the queue for UART1.
           PIC24-30-33

tx2        ( c -- )
           Send a character to UART 2.
           PIC18-24-30-33

tx2q       ( -- queue-addr )
           Leave the address of the queue for UART2.
           PIC24-30-33

tx3        ( c -- )
           Send a character to UART 2.
           PIC18

txu        ( c -- )
           Send a character to USB UART.
           PIC18 USB

u0-        ( -- )
           Disable flow control for UART0 serial interface

u0+        ( -- )
           Enable flow control for UART0 serial interface (Default)

u1-        ( -- )
           Disable flow control for UART1 serial interface

u1+        ( -- )
           Enable flow control for UART1 serial interface (Default)

u2-        ( -- )
           Disable flow control for UART2 serial interface

u2+        ( -- )
           Enable flow control for UART2 serial interface (Default)


u*/mod     ( u1 u2 u3 -- u4(remainder) u5(quotient) )
           Unsigned u1*u2/u3 with 32 bit intermediate result

u.         ( u -- )
           Display u unsigned according to numeric base

u.r        ( u +n -- )
           Display u in field of width n. 0<n<256

u/         ( u1 u2 -- u3 )
           Unsigned 16/16->16 bit division

u/mod      ( u1 u2 -- u3(remainder) u4(quotient)
           Unsigned 16/16->16 bit division

u<         ( u1 u2 -- flag )
           Leave true flag if u1 is less than u2

u>         ( u1 u2 -- flag )
           Leave true flag if u1 is greater than u2

ud.        ( ud -- )
           Display unsigned double number
           
ud*        ( ud u -- ud )
           Unsigned 32x16 -> 32 bit multiply

ud/mod     ( ud u -- u(remainder) ud(quotient)
           unsigned 32/16 -> 32 bit division

ulink      ( -- a-addr)
           Link to next task

um*        ( u1 u2 -- ud )
           Unsigned 16x16 -> 32 bit multiply

um/mod     ( ud u1 -- u2(remainder) u3(quotient)
           unsigned 32/16 -> 16 bit division

umax       ( u1 u2 -- u )
           Leave the unsigned larger of u1 and u2.

umin       ( u1 u2 -- u )
           Leave the unsigned smaller of u1 and u2.

until      ( flag -- )   COMPILE_ONLY
           begin..until

up         ( -- a-addr )
           Variable holding the user pointer

user       ( +n "name" -- )
           Define a user variable at offset +n

usb+       ( -- )
           Start the USB serial interface
           PIC18 PIC24

usb-       ( -- )
           Stop the USB serial interface
           PIC18 PIC24

uq*        ( ud ud -- uq )
           Multiply two double numbers to a quad result
           PIC18 PIC24 PIC30 PIC33

uq/mod     ( qu du -- du-rem du-quot )
           Divide a 64 bit unsigned number with a 32 bit unsigned number
           PIC18 PIC24 PIC30 PIC33

d>q        ( d -- q )
           Extend a double number to a quad number
           PIC18 PIC24 PIC30 PIC33

q+         ( q q -- q )
           Add a quad number to quad number
           PIC24 PIC30 PIC33

qm+        ( q d -- q )
           Add a double number to quad number
           PIC18 PIC24 PIC30 PIC33

um*/       ( ud1 u1 u2 -- ud2 )
           Scale with triple number intermediate result

unused     ( -- x )
           Get the amount of unused memory in the current data section

ut*        ( ud u -- ut )
           Multiply single number with double number

ut/        ( ut u -- ud )
           Divide triple number with single number

value      ( x "name" -- )
           Define a value

variable   ( "name" -- )
           Create a variable in the current data section

warm       ( -- )
           Make a warm start
           Reset Reasons displayed after start:
           S: Reset instruction
           E: External reset pin
           W: Watchdog reset
           U: Return stack underflow
           O: Return stack overflow
           B: Brown out reset
           P: Power on reset
           M: Math Error
           A: Address error

wd+        ( n -- )
           WatchDog On. n = 0..7. 0=16 ms. 7=2000 ms.
           ATMEGA

wd-        ( -- )
           WatchDog Off.
           ATMEGA

while      (addr1 -- addr2 addr1 )  COMPILE_ONLY
           begin ... while ... repeat

within     ( x xl xh -- flag )
           Leave true if  xl <= x < xh

word       ( c -- c-addr )
           Parse a word in TIB and write the length into TIB
           Leave the address of the length byte on the stack.

wmove      ( addr1 addr2 u -- )
           Move u cells from addr1 to addr2
           PIC24-30-33

words xxx  ( "name" -- )
           List words optionally filtered with xxx

x!         ( u addr.d -- )
           Extended store into flash. Real flash address
           PIC18 ATMEGA

x@         ( addr.d -- u )
           Extended fetch from flash. Real flash address
           PIC18 ATMEGA

x@         ( addr.d -- ud )
           Extended fetch from flash. Real flash address
           PIC24-30-33

xa>        ( a-addr1 -- a-addr2 )
           Convert a real executable address to virtual flash address
           PIC24-30-33 ATMEGA

xor        ( x1 x2 -- x3 )
           Xor bitwise x1 with x2.

Atmega Assembler
================
Conditionals
------------
if,    ( cc -- addr )
else,  ( addr -- addr' )
then,  ( addr -- )
begin, ( -- addr )
until, ( addr cc -- )
again, ( addr -- )

Condition codes for if, and until,
----------------------------------
cs,    ( -- cc )   if,/until, carry set
eq,    ( -- cc )   if,/until, zero
hs,    ( -- cc )   if,/until, half carry set
ie,    ( -- cc )   if,/until, interrupt enabled
lo,    ( -- cc )   if,/until, lower
lt,    ( -- cc )   if,/until, less than
mi,    ( -- cc )   if,/until, negative
ts,    ( -- cc )   if,/until, T flag set
vs,    ( -- cc )   if,/until, no overflow
not,   ( cc -- not-cc ) Invert the condition code

Assembly words
--------------
adc,    ( Rd Rr -- )    Rd = Rd + Rr + C
add,    ( Rd Rr -- )    Rd = Rd + Rr
adiw,   ( Rw k6 -- )    Rdh:Rdl = Rdh:Rdl + k
and,    ( Rd Rr -- )    Rd =- Rd AND Rr
andi,   ( Rd k -- )     Rd = Rd AND k
asr,    ( Rd -- )       Rd(n) = Rd(n+1), n=0..6
bclr,   ( s -- )        SREG(s) = 0
bld,    ( Rd b -- )     Rd(b) = T
break,  ( -- )          Break
bset,   ( s -- )        SREG(s) = 1
bst,    ( Rr b -- )     T = Rr(b)
call,   ( k16 k6 -- )   PC = k
cbi,    ( P b -- )      I/O(P,b) = 0
cbr,    ( Rd k -- )     Rd = Rd AND (0xFF - k)
clc,    ( -- )          C = 0
clh,    ( -- )          H = 0
cli,    ( -- )          I = 0
cln,    ( -- )          N = 0
clr,    ( Rd -- )       Rd = 0
cls,    ( -- )          S = 0
clt,    ( -- )          T = 0
clv,    ( -- )          V = 0
clz,    ( -- )          Z = 0
com,    ( Rd -- )       Rd = 0xFF -Rd
cp,     ( Rd Rr -- )    ZNVCH <- Rd - Rr
cpc,    ( Rd Rr -- )    ZNVCH <- Rd - Rr - C
cpi,    ( Rd k -- )     ZNVCH <- Rd - k
cpse,   ( Rd Rr -- )    if (Rd = Rr) Skip Next Instruction
dec,    ( Rd -- )       Rd = Rd - 1
eicall, ( -- )          Stack <- PC; PC = (EIND:Z)
eijmp,  ( -- )          PC = (EIND:Z)
eor,    ( Rd Rr -- )    Rd = Rd XOR Rr
fmul,   ( Rd Rr -- )    R1:R0 = (Rd x Rr) << 1
fmuls,  ( Rd Rr -- )    R1:R0 = (Rd x Rr) << 1
fmulsu, ( Rd Rr -- )    R1:R0 = (Rd x Rr) << 1
icall,  ( -- )          Stack <- PC; PC = Z
ijmp,   ( -- )          PC = Z
in,     ( Rd P -- )     Rd = P
inc,    ( Rd -- )       Rd = Rd + 1
jmp,    ( k16 k6 -- )   PC = k
ld,     ( Rd Rr -- )    Rd = Rr, Rr={Z+,-Z,Y+,-Y,X+,-X,X,Y,Z}
ldd,    ( Rd RR q -- )  Rd = (RR + q), RR = {Y,Z}
ldi,    ( Rd k -- )     Rd = k
lds,    ( Rd k16 -- )   (k) = Rd
lsl,    ( Rd -- )       Rd(n+1) = Rd(n), Rd(0) ← 0
lsr,    ( Rd -- )       Rd(n) = Rd(n+1), Rd(7) ← 0
mov,    ( Rd Rr -- )    Rd = Rr
movw,   ( Rd Rr -- )    Rd+1:Rd = Rr+1:Rr
mul,    ( Rd Rr -- )    R1:R0 = Rd x Rr
muls,   ( Rd Rr -- )    R1:R0 = Rd x Rr
neg,    ( Rd -- )       Rd = 0x00 − Rd
nop,    ( -- )          No Operation
or,     ( Rd Rr -- )    Rd = Rd v Rr
ori,    ( Rd k -- )     Rd = Rd v K
out,    ( Rr P -- )     P = Rr
pop,    ( Rd -- )       Rd = STACK
push,   ( Rd -- )       STACK = Rr
rcall,  ( k12 -- )      PC = PC + k + 1
ret,    ( -- )          PC = STACK
reti,   ( -- )          PC = STACK
rjmp,   ( k12 -- )      PC = PC + k + 1
rol,    ( Rd -- )       Rd(0) = C, Rd(n+1) = Rd(n),C = Rd(7)
ror,    ( Rd -- )       Rd(7) = C, Rd(n) = Rd(n+1),C= Rd(0)
sbc,    ( Rd Rr -- )    Rd = Rd - Rr - C
sbci,   ( Rd k -- )     Rd = Rd - K - C
sbi,    ( P b -- )      I/O(P,b) = 1
sbic,   ( P b -- )      if (P(b)=0)  Skip Next Instruction
sbis,   ( P b -- )      if (P(b)=1)  Skip Next Instruction
sbiw,   ( Rw k6 -- )    Rdh:Rdl = Rdh:Rdl - K
sbr,    ( Rd k -- )     Rd = Rd v K
sbrc,   ( Rd b -- )     if (Rr(b)=0) Skip Next Instruction
sbrs,   ( Rd b -- )     if (Rr(b)=1) Skip Next Instruction
sec,    ( -- )          C=1
seh,    ( -- )          H=1
sei,    ( -- )          I=1
sen,    ( -- )          N=1
ser,    ( Rd -- )       Rd = 0xFF
ses,    ( -- )          S=1
set,    ( -- )          T=1
sev,    ( -- )          V=1
sez,    ( -- )          Z=1
sleep,  ( -- )          Sleep
st,     ( Rr RD -- )    (RD) = Rr, RD = {X,Y,Z,X+,-X,Y+,-Y,Z+,-Z}
std,    ( Rr RD q -- )  (RD + q) = Rr, RD = {Y,Z} 
sts,    ( k16 Rd -- )   (k) = Rr
sub,    ( Rd Rr -- )    Rd = Rd - Rr
subi,   ( Rd k -- )     Rd = Rd - K
swap,   ( Rd -- )       Rd(3..0) = Rd(7..4), Rd(7..4) = Rd(3..0)
tst,    ( Rd -- )       Rd = Rd AND Rd
wdr,    ( -- )          Watchdog Reset

Register constants
------------------
RD RR registers
------------
Z       ( -- 0 )
Z+      ( -- 1 )
-Z      ( -- 2 )
Y       ( -- 8 )
Y+      ( -- 9 )
-Y      ( -- 10 )
X       ( -- 12 )
X+      ( -- 13 )
-X      ( -- 14 )

Rw registers
------------
XH:XL   ( -- 01 )
YH:YL   ( -- 02 )
ZH:ZL   ( -- 03 )


Rd Rr registers
---------------
R0      ( -- 0 )
R1      ( -- 1 )
R2      ( -- 2 )
R3      ( -- 3 )
R4      ( -- 4 )
R5      ( -- 5 )
R6      ( -- 6 )
R7      ( -- 7 )
R8      ( -- 8 )
R9      ( -- 9 )
R10     ( -- 10 )
R11     ( -- 11 )
R12     ( -- 12 )
R13     ( -- 13 )
R14     ( -- 14 )
R15     ( -- 15 )
R16     ( -- 16 )
R17     ( -- 17 )
R18     ( -- 18 )
R19     ( -- 19 )
R20     ( -- 20 )
R21     ( -- 21 )
R22     ( -- 22 )
R23     ( -- 23 )
R24     ( -- 24 )
R25     ( -- 25 )
R26     ( -- 26 )
R27     ( -- 27 )
R28     ( -- 28 )
R29     ( -- 29 )
R30     ( -- 30 )
R31     ( -- 31 )
