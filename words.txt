words 
p2+ pad pc@ @p ddrb portb hi unused d. ud. d> d< d= d0< d0= dinvert d2* d2/ d- d+ dabs ?dnegate dnegate s>d rdrop endit next for in, inline repeat while again until begin then else if zfl pfl xa> >xa x>r dump .s words >pr .id ms ticks r0 s0 latest state bl 2- ['] -@ ; :noname : ] [ does> postpone create cr [char] ihere ( char ' lit abort" ?abort ?abort? abort prompt quit true false .st inlined immediate shb interpret 'source >in tiu tib ti# number? >number ud/mod ud* sign? digit? find immed? (f) c>n n>c @+ c@+ place cmove word parse \ /string source user base hb hp task ulink rsave bin hex decimal . u.r u. sign #> #s # digit <# hold up min max ?negate tuck nip / u*/mod u/ * u/mod um/mod um* 'key? 'key 'emit p++ p+ pc! p! p@ r>p !p>r !p u> u< > < = 0< 0= <> within +! 2/ 2* >body 2+ 1- 1+ negate invert xor or and - m+ + abs dup r@ r> >r rot over swap drop allot ." ," s" (s" type accept 1 umax umin spaces space 2over 2swap 2dup 2drop 2! 2@ cf, chars char+ cells cell+ aligned align cell c, , here dp ram eeprom flash >< rp@ sp! sp@ 2constant constant 2variable variable @ex execute key? key emit Fcy mtst scan skip n= rshift lshift mclr mset ic, i, operator iflush cwd wd- wd+ pause turnkey to is defer value fl+ fl- c! c@ @ a> ! >a literal int! ;i di ei ver warm empty rx0? rx0 tx0 load- load+ busy idle exit 
-end_328P_HAL init_T0_OV T0_OVF_ISR dis_T0_OVF clr_pressed_2 check_btn_2 pressed_2? btn_pressed_2? str_history_2 down_2? pressed_true_2 init_history_2 count_2 pressed_2 history_2 clr_pressed_1 check_btn_1 pressed_1? btn_pressed_1? str_history_1 down_1? pressed_true_1 init_history_1 count_1 pressed_1 history_1 BTN_DOWN BTN_MASK clock0_per T0_OVF_VEC TIMSK0 OCR0A TCCR0B TCCR0A -T0_int -end_HAL falkey read pullup input output toggle low high .mem_left us wdr, op: -us D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11 D12 D13 LED A0 A1 A2 A3 A4 A5 BIT0 BIT1 BIT2 BIT3 BIT4 BIT5 BIT6 BIT7 PORTD DDRD PIND PORTC DDRC PINC PORTB DDRB PINB marker  